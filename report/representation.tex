So far we have described how nodes and edges of the graph are obtained from documents and their
similarity. In order to display the graph, a graph layout (two dimensional representation of the
graph) must be determined. If the vector representation of the document is only two dimensional,
then it is straightforward to obtain the graph layout just by using the features as two dimensional
coordinates. However, the documents in our model are represented by vectors with several thousands
of dimensions. The problem of reducing the dimensionality, is usually not solved by mapping
from high dimensional vector space to the low dimensional vector space but by using algorithms that
solve the problem of graph layouting directly using only the properties of the underlying graph
(nodes and edges together with their weights).

\subsubsection{Computing Graph Layouts}
The layouting algorithm that was used in this project belongs to the popular class of force-based
layout algorithms which are based on physical modeling. An Edge is considered a spring and
the nodes are considered to be electrically charged particles (i.e.\ with equal signed charge such
that they repel each other) The optimal length of the springs is set in advance. Springs whose
length is larger or smaller than their optimal length exert a force that acts on the connected
nodes. In each iteration of the layouting algorithm, nodes are moved according to the resultant
force
that acts on them. After some time the position of the nodes becomes (quasi) stationary and the
system get into a local equilibrium state.

The described class of force based layout algorithms subsumes various algorithms with different
properties. However, they all perform variations of force-field energy minimization by iterative
approximation schemes. In this project the very basic algorithm as it is described in the previous
paragraph was used.

\subsubsection{Jung Graph Framework}
For the purpose of graph layouting, graph painting and user-graph interaction, the
\texttt{Jung - java universal network/graph framework} was used \cite{jung}. It provides great
flexibility in adjusting the graph appearance. Several so-called transformers which affect node and
edge label appearance can be plugged together to result in the aesthetically pleasant appearance.
\texttt{Jung} also provides predefined classes that allow for easy interaction with the user.
Functionalities for graph translation, zooming, node selection, node transposition and other
features can be achieved with minimal programming effort. One notably strong point of the library is
its template based design with the possibility to include several plug-in components such as
rendering and transformers that affect the resulting appearance of the graph.

However there are some aspects of the \texttt{Jung} library, that were annoying fro the project.
First, it is difficult to achieve certain low level functionalities, like e.g.\ monitoring the
on-screen position of a fixed point while translation of the graph was performed. Secondly, several
operation are implemented in a circumstantial way. For example, in order to change the color of
one node the whole graph must be redrawn and during this process all active visualization
transformers are applied on each graph object.When we used the default implementation of the
\texttt{Jung} visualization class, the application consumed more then 50\% of the processor time
even though there was no ongoing user interaction or computation task (this depended on the size of
the presented graph --- the statement holds for graph with 25 nodes about 50 edges). By extending
the standard \texttt{Jung VisualizationViewer} class and overriding several functions, the issue of
unnecessary graph redrawing was resolved and accordingly the problem of the low gui performance.

\subsubsection {Querying Functionalities}
\label{sec:querying_functionalities}
The nodes of the graph are generated from the results of a database query supplied by the user, who
can search either by keyword, by NE, or by a combination of both in the same query. Likewise, the
user may select a range of years to search in (e.g.\ retrieve documents occurring between
\code{1970} and \code{1975}), as well as select only certain types of documents to be searched
(e.g.\ retrieve only documents of type \meta{Speech} or \meta{Interview}). The documents most
relevant to the current query are displayed, the number of the documents displayed being specified
by the user (e.g.\ display the \code{25} most relevant documents), and edges connecting each
document are drawn based on the similarity measures relating each document to each other.

\subsubsection {Presenting Results}
\label{sec:presenting_results}
After submitting a query, a table of query results is displayed and a graph corresponding to the
results is drawn, in which the relevance measure of each document to the current query is
represented by the absolute size of the node representing the document in question: The larger the
node, the more relevant it is to the current query. The type of document represented by the node is
represented by its shape, e.g.\ \meta{Speech} $\rightarrow$ star, \meta{Meeting} $\rightarrow$
pentagon. The edges linking the nodes of the graph represent the strength of similarity the of the
two documents represented by the nodes.