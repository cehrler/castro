\note{MICHAL - EXPAND SECTION WITH STUFF ABOUT THE COMPUTATIONAL, ALGORITHMIC, AND IMPLEMENTATION STUFF.}

So far we have described how the nodes and edges in the graph are obtained. In order to display the graph, a graph layout (two dimensional representation of the graph) must be determined. If our vector representation of the document was only two dimensional then it would be very straightforward to obtain the graph layout
by just using the two feature values as x and y coordinates. However the document in the described model is represented by the vector of several thousands of dimensions. This problem is usually not solved by direct mapping from high dimensional vector space to the low dimensional vector space. There are algorithm that solve the problem of graph layouting directly by using only the properties of the underlying graph (nodes and edges together with their weights).

The layouting algorithm that was used in our project belongs to the popular class of the layouting algorithms called force-based layout algorithms. In this class of algorithms physical modelling is used. Spring is considered to be string and the node is considered to be electrically charged particle (all the nodes have the same charge). The optimal length of the edge/spring is set in advance. if the length of the edge exceeds the optimal value, then there is a power between connected nodes trying to push them together. If the distance of two nodes is lower than the predefined repulsion distance, then there is a repulsion power trying to push them apart. In each iteration of the layouting algorithm nodes are moved acording to the resultant force that takes effect on them. After some time the position of the nodes becomes stationary, the layout achieves so called equilibrum state.

The class of forse based layout algorithms groups together various different algorithms with different properties. The idea of a metaphor between nodes and edges of the graph and the real world object that interact together and the step by step simulation are their common properties. In our project we used the very basic algorithm as it is described in the previous article.

For the purpose of graph layouting, graph painting and user-graph interaction, we used Jung - java universal network/graph library. It provides great flexibility of adjusting the graph appearence. Several transformers that affect the node label, label and edge appearence can be plugged together to result in the aesthetically pleasent appearence. There are also predefined classes that allows the easy interaction with the user. Functionalities of graph translating, zooming, node picking, node transposition and many others can be achieved with minimal programming effort. The strong point of the library is it's design based on general template classes with the possibility to include several pluggable component such as various renderers and transformers that affect the resulting appearance of the graph. 

However there were few aspects of the jung library, that we found annoying. We found it difficult to achieve some low level functionalities such as retrieving the changing position of fixed staring point in the actual graphical representation, when the graph translating is performed. Also several operation are done in quite inefficient way. For example in order to change the color of one node, the whole graph must be redrawn asking all the vizualization transformer on the appearence of each vertex or node. When we used a default implementation of a jung visualization class, the application consumed more then 50\% of the processor capacity even though there was no user interaction or computation task. Then we found out that the low performance is caused by the fact that the jung library completely redraws the whole graph several times each second without actual reason for doing so (It doesn't only redraw the graph by displaying precomputed bitmap, it actually determines the graph appearence from scretch by calling all its transformers and renderers, which is really computationaly expensive). By extending the standard jung VisualizationViewer class and overriding few functions, that resolved the issue of unnecesarry graph redrawing, we solved the problem of the low gui performance. We don't grant that there is no easy solution for the described problem, but the fact that we couldn't actually find it gave us the notion, that there are few weak points in the design of the library.

\subsubsection {Querying Functionalities}
\label{sec:querying_functionalities}
The nodes of the graph are generated from the results of a database query supplied by the user, who can search either by keyword, by NE, or by a combination of both in the same query. Likewise, the user may select a range of years to search in (e.g.\ retrieve documents occurring between \code{1970} and \code{1975}), as well as select only certain types of documents to be searched (e.g.\ retrieve only documents of type \meta{Speech} or \meta{Interview}). The documents most relevant to the current query are displayed, the number of the documents displayed being specified by the user (e.g.\ display the \code{25} most relevant documents), and edges connecting each document are drawn based on the similarity measures relating each document to each other.

\subsubsection {Presenting Results}
\label{sec:presenting_results}
After submitting a query, a table of query results is displayed and a graph corresponding to the results is drawn, in which the relevance measure of each document to the current query is represented by the absolute size of the node representing the document in question: The larger the node, the more relevant it is to the current query. The type of document represented by the node is represented by its shape, e.g.\ \meta{Speech} $\rightarrow$ star, \meta{Meeting} $\rightarrow$ pentagon. The edges linking the nodes of the graph represent the strength of similarity the of the two documents represented by the nodes.
