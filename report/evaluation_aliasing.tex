As described in section \ref{sec:aliasing} string kernels allow greater flexibility than other common string similarity measures such as edit distance.
For example, the following organizations are identified as aliases of each other:
\begin{enumerate}
\item  \lingform{Public Health Ministry}
\item  \lingform{PublicHealth Ministry}
\item  \lingform{Public HealthMinistry}
\item  \lingform{Ministryof Public Health}
\item  \lingform{Ministry ofPublic Health}
\item  \lingform{Ministry of Public Health}
\item  \lingform{Ministry of PublicHealth}
\end{enumerate}
All the items in this group seem to refer to the same extra-linguistic object. Items 1--3 are very close to each other in terms of edit distance.
The same can also be said about items 4--7. String kernels not only account for these similarities, but also associate between the different word arrangements of the expression. Using edit distance would not be able to bind such cases. A related example is the location \lingform{Delhi} and its aliases 
\lingform{NewDelhi} and \lingform{New Delhi}. Here, the additional value of the string kernel method comes in the form of associating the shorter version of the
name with its longer variant. 

However, in many cases, the flexibility of string kernels results in associating named entities which are entirely unrelated to each other. For example: \lingform{Polish People's Republic}, \lingform{Lao People's Republic}, \lingform{Mongolian People's Republic}

This is particularly problematic with names of people. For instance, there are 21 different people
whose last name is \lingform{Rodriguez} (or a variant of this name) and who were wrongly aliased
together. Another case of common mistakes are long titles such as \lingform{Comrade} which create
rather large clusters of unrelated names.   
 
Naturally, along with the cases of clear success and those of clear failure, many aliases contain a mixture of correct and incorrect bindings, as well as bindings whose correctness can only be determined in context--- consider:

\begin{enumerate}
 \item \lingform{Raul Castro}
 \item \lingform{MajRaul Castro}
 \item \lingform{GenRaul Castro}
 \item \lingform{RaulCastro}
 \item \lingform{Mr Castro}
 \item \lingform{F. Castro}
 \item \lingform{Dr Castro}
 \item \lingform{RaulCastro Ruz}
 \item \lingform{Maj RaulCastro}
 \item \lingform{Gen RaulCastro}
 \item \lingform{Raul Castro Ruz}
 \item \lingform{Maj Raul Castro}
 \item \lingform{Gen Raul Castro}
\end{enumerate}

Most of the strings above refer to the same entity (Raul Castro), with the exception of \lingform{F. Castro}, which clearly refers to a different entity, as well as \lingform{Mr Castro} and \lingform{Dr Castro} (the correctness of these forms being dependent on context).

By examining the outputs of using different similarity thresholds, it was found that the original assumption that the trade-off between recall and precision can be partially regulated by adjusting the similarity threshold. A higher threshold leads to higher recall but lower precision, while lower threshold improves precision at the expense of recall. As our similarity measures heavily rely on the accuracy of the aliases, we preferred to use a relatively high inter-NE similarity threshold (0.75) in order to maximize precision while retaining some of the flexibility the method has to offer. The examples presented above were generated with this threshold.

However, even given this setup, the mechanism has considerable over-generation, which then leads to unjustified linking between documents which is a crucial problem. The noise produced by the aliasing over-generation is possibly the major drawback of our system. We discuss solutions for this situation in the future research section \ref{sec:future_work_NLP}.


